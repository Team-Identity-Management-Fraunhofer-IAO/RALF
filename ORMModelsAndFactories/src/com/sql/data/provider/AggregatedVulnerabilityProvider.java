package com.sql.data.provider;

import java.math.BigDecimal;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.query.NativeQuery;

import com.sql.data.objects.aggregations.AggregatedVulnerability;
import com.sql.data.objects.aggregations.AggregatedVulnerabilityRepository;
import com.sql.data.objects.aggregations.VulnerablePlatformCombination;
import com.sql.data.objects.persistence.platforms.CPECore;
import com.sql.data.objects.persistence.platforms.ContainsPlatform;
import com.sql.data.objects.persistence.platforms.PlatformCombination;
import com.sql.hibernate.HibernateInstance;

@Deprecated
public class AggregatedVulnerabilityProvider {
	private SessionFactory hibernateSessionFactory;
	private Map<String, Integer> indexMap;

	private void instantiateHibernateSessionFactory() {
		if (hibernateSessionFactory == null) {
			hibernateSessionFactory = HibernateInstance.getSessionFactory();
		}
	}

	public AggregatedVulnerabilityProvider() {
		indexMap = new HashMap<String, Integer>();
		indexMap.put("cveYear", 0);
		indexMap.put("cveID", 1);
		indexMap.put("identifierString", 2);
		indexMap.put("vectorString", 3);
		indexMap.put("attackVector", 4);
		indexMap.put("attackComplexity", 5);
		indexMap.put("privilegesRequired", 6);
		indexMap.put("userInteraction", 7);
		indexMap.put("scope", 8);
		indexMap.put("confidentialityImpact", 9);
		indexMap.put("integrityImpact", 10);
		indexMap.put("availabilityImpact", 11);
		indexMap.put("baseScore", 12);
		indexMap.put("baseSeverity", 13);
		indexMap.put("exploitabilityScore", 14);
		indexMap.put("impactScore", 15);
		indexMap.put("confID", 16);
		indexMap.put("relationship_operator", 17);
		indexMap.put("node_operator", 18);
		indexMap.put("combinationID", 19);
		indexMap.put("operator", 20);
		indexMap.put("vulnerable", 21);
		indexMap.put("URI", 22);
		indexMap.put("standardized", 23);
		indexMap.put("descriptionText", 24);
	}

	private String checkForWildcards(String value) {
		if (value.equals("-")) {
			return "IN ('*','-')";
		}else if (value.equals("*")) {
			return null;
		} else if (value.contains("*")) {
			return "LIKE " + value.replace("*", "%");
		} else {
			return "=\"" + value + "\"";
		}
	}
	
	/*
	public AggregatedVulnerabilityRepository aggregateVulnerabilitiesForCPE(CPECore cpe) {
		instantiateHibernateSessionFactory();
		String selectionSubQuery = "";
		String cpe_language = checkForWildcards(cpe.getCpe_language());
		String cpe_update = checkForWildcards(cpe.getCpe_update());
		String edition = checkForWildcards(cpe.getEdition());
		String other = checkForWildcards(cpe.getOther());
		String part = checkForWildcards(cpe.getPart());
		String product = checkForWildcards(cpe.getProduct());
		String sw_edition = checkForWildcards(cpe.getSw_edition());
		String target_hw = checkForWildcards(cpe.getTarget_hw());
		String target_sw = checkForWildcards(cpe.getTarget_sw());
		String vendor = checkForWildcards(cpe.getVendor());
		if (cpe_language != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "cpe_language " + cpe_language;
		}
		if (cpe_update != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "cpe_update " + cpe_update;
		}
		if (edition != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "edition " + edition;
		}
		if (other != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "other " + other;
		}
		if (part != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "part " + part;
		}
		if (product != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "product " + product;
		}
		if (sw_edition != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "sw_edition " + sw_edition;
		}
		if (target_hw != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "target_hw " + target_hw;
		}
		if (target_sw != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "target_sw " + target_sw;
		}
		if (vendor != null) {
			selectionSubQuery += (selectionSubQuery.equals("") ? "" : " AND ") + "vendor " + vendor;
		}
		System.out.println(selectionSubQuery);
		String version = cpe.getVersion();
		String versionSubQuery = "";
		if (version.equals("-")) {
			versionSubQuery = "WERE version =\"" + version + "\" ";
		} else if (!version.equals("*")) {
			versionSubQuery = "WHERE IF(versionStart IS NULL,TRUE,IF(startIncluding IS TRUE,versionStart<=\""
					+ (version) + "\",versionStart<\"" + (version)
					+ "\")) AND IF(versionEnd IS NULL,TRUE,IF(endIncluding IS TRUE,versionEnd >= \"" + (version)
					+ "\",versionEnd > \"" + (version)
					+ "\")) AND IF((versionStart IS NULL) AND (versionEnd IS NULL),version = \"" + (version)
					+ "\",TRUE) AND vulnerable";
		} else {
			versionSubQuery = "";
		}

		String queryString = "SELECT cveProcess.*, description.descriptionText " + "FROM " + "description " + "JOIN "
				+ "(SELECT " + "cve.*,"
				+ "configuration.confID, configuration.relationship_operator, configuration.node_operator, configuration.combinationID, configuration.operator, configuration.vulnerable, configuration.URI, configuration.standardized "
				+ "FROM " + "cve " + "JOIN " + "(SELECT "
				+ "configuration_node.cveID, configuration_node.cveYear, configuration_node.confID, configuration_node.relationship_operator, configuration_node.node_operator, combination_platform.combinationID, combination_platform.operator, combination_platform.vulnerable, combination_platform.URI, combination_platform.standardized "
				+ "FROM " + "configuration_node " + "JOIN " + "(SELECT "
				+ "platform_combination.combinationID, platform_combination.confID, platform_combination.operator, platform_cpe.vulnerable, platform_cpe.versionStart, platform_cpe.versionEnd, platform_cpe.startIncluding, platform_cpe.endIncluding, platform_cpe.URI, platform_cpe.standardized, platform_cpe.version "
				+ "FROM " + "platform_combination " + "JOIN " + "(SELECT "
				+ "contains_platform.combinationID, contains_platform.vulnerable, contains_platform.versionStart, contains_platform.versionEnd, contains_platform.startIncluding, contains_platform.endIncluding, cpe.* "
				+ "FROM " + "contains_platform " + "JOIN " + "(SELECT "
				+ "cpe.cpeID, cpe.URI, cpe.version, cpe.standardized " + "FROM cpe "
				+ (selectionSubQuery.equals("") ? "" : " WHERE ") + selectionSubQuery + ") " + "AS" + " cpe "
				+ "ON (cpe.cpeID = contains_platform.cpeID) " + versionSubQuery + ") " + "AS " + "platform_cpe " + "ON "
				+ "(platform_cpe.combinationID = platform_combination.combinationID) " + ") " + "AS "
				+ "combination_platform " + "ON " + "(combination_platform.confID = configuration_node.confID) " + ") "
				+ "AS " + "configuration " + "ON "
				+ "(configuration.cveID = cve.cveID) AND (configuration.cveYear = cve.cveYear) " + ") " + "AS "
				+ "cveProcess " + "ON\r\n"
				+ "(cveProcess.cveID = description.cveID) AND (cveProcess.cveYear = description.cveYear);";
		System.out.println(queryString);
		Session session = hibernateSessionFactory.openSession();
		NativeQuery<Object[]> query = session.createNativeQuery(queryString);
		List<Object[]> rows = query.list();
		/*
		 * cveYear 0, cveID 1, identifierString 2, vectorString 3, attackVector 4,
		 * attackComplexity 5, privilegesRequired 6, userInteraction 7, scope 8,
		 * confidentialityImpact 9, integrityImpact 10, availabilityImpact 11, baseScore
		 * 12, baseSeverity 13, exploitabilityScore 14, impactScore 15, confID 16,
		 * relationship_operator 17, node_operator 18, combinationID 19, operator 20,
		 * vulnerable 21, URI 22, standardized 23, descriptionText 24
		 * AggregatedVulnerability(cveYear, cveID, identifierString, vectorString,
		 * attackVector, attackComplexity, privilegesRequired, userInteraction, scope,
		 * confidentialityImpact, integrityImpact, availabilityImpact, baseScore,
		 * baseSeverity, exploitabilityScore, impactScore, confID,
		 * relationship_operator, node_operator, combinationID, operator, vulnerable,
		 * uRI, standardized, descriptionText);
		 *//*
		AggregatedVulnerabilityRepository repository = null;
		ContainsPlatformProvider cPlatformProvider = null;
		PlatformCombinationProvider platformCombinationProvider = null;
		CPEProvider cpeProvider = null;
		for (Object[] vuln : rows) {
			if (repository == null) {
				repository = new AggregatedVulnerabilityRepository();
			}
			repository.setName(cpe.getURI());
			try {
				AggregatedVulnerability agVuln = new AggregatedVulnerability((Integer) vuln[indexMap.get("cveYear")],
						(Integer) vuln[indexMap.get("cveID")], (String) vuln[indexMap.get("identifierString")],
						(String) vuln[indexMap.get("vectorString")], (String) vuln[indexMap.get("attackVector")],
						(String) vuln[indexMap.get("attackComplexity")],
						(String) vuln[indexMap.get("privilegesRequired")],
						(String) vuln[indexMap.get("userInteraction")], (String) vuln[indexMap.get("scope")],
						(String) vuln[indexMap.get("confidentialityImpact")],
						(String) vuln[indexMap.get("integrityImpact")],
						(String) vuln[indexMap.get("availabilityImpact")],
						String.valueOf((BigDecimal) vuln[indexMap.get("baseScore")]),
						(String) vuln[indexMap.get("baseSeverity")],
						String.valueOf((BigDecimal) vuln[indexMap.get("exploitabilityScore")]),
						String.valueOf((BigDecimal) vuln[indexMap.get("impactScore")]),
						(Integer) vuln[indexMap.get("confID")], (String) vuln[indexMap.get("relationship_operator")],
						(String) vuln[indexMap.get("node_operator")], (Integer) vuln[indexMap.get("combinationID")],
						(String) vuln[indexMap.get("operator")], (Boolean) vuln[indexMap.get("vulnerable")],
						(String) vuln[indexMap.get("URI")], (Boolean) vuln[indexMap.get("standardized")],
						(String) vuln[indexMap.get("descriptionText")]);
				if (!agVuln.isVulnerable()) {
					agVuln = null;
					continue;
				}
				/*if (agVuln.getOperator() != null) {
					if (agVuln.getOperator().equals("AND")) {
						if (cPlatformProvider == null) {
							cPlatformProvider = new ContainsPlatformProvider();
						}
						if (cpeProvider == null) {
							cpeProvider = new CPEProvider();
						}
						List<ContainsPlatform> cPlatformList = cPlatformProvider
								.findByCombinationIDExclusionAndConfId(agVuln.getCombinationID(), agVuln.getConfID());
						for (ContainsPlatform cPlatform : cPlatformList) {
							List<CPECore> cpeList = cpeProvider
									.getCPEsByContainsPlatformId(cPlatform.getCombinationID());
							VulnerablePlatformCombination cpeCombination = new VulnerablePlatformCombination();
							cpeCombination.getPlatforms().addAll(cpeList);
							agVuln.getPlatformCombinations().add(cpeCombination);
						}
					}
				}
				if (agVuln.getNode_operator() != null) {
					if (agVuln.getNode_operator().equals("AND")) {
						// Aus platform combination alle objekte mit confId holen
						// ANschlieﬂend wie oben
						if (platformCombinationProvider == null) {
							platformCombinationProvider = new PlatformCombinationProvider();
						}
						if (cPlatformProvider == null) {
							cPlatformProvider = new ContainsPlatformProvider();
						}
						// Get all Correlated Platforms
						List<ContainsPlatform> correlatedPlatformList = cPlatformProvider
								.findByCombinationIDExclusionAndConfId(agVuln.getCombinationID(), agVuln.getConfID());
						for (ContainsPlatform correlatedPlatform : correlatedPlatformList) {
							PlatformCombination pCombination = platformCombinationProvider
									.find(correlatedPlatform.getCombinationID());
							if (cpeProvider == null) {
								cpeProvider = new CPEProvider();
							}
							List<CPECore> correlatedCPEList = cpeProvider
									.getCPEsByContainsPlatformId(correlatedPlatform.getCombinationID());

							if (pCombination.getOperator() != null && pCombination.getOperator().equals("OR")) {
								for (CPECore correlatedCPE : correlatedCPEList) {
									VulnerablePlatformCombination vulnPlatformCombination = new VulnerablePlatformCombination();
									vulnPlatformCombination.getPlatforms().add(correlatedCPE);
									agVuln.getPlatformCombinations().add(vulnPlatformCombination);
								}
							} else if (pCombination.getOperator().equals("AND")) {
								VulnerablePlatformCombination vulnPlatformCombination = new VulnerablePlatformCombination();
								vulnPlatformCombination.getPlatforms().addAll(correlatedCPEList);
								agVuln.getPlatformCombinations().add(vulnPlatformCombination);
							}
						}

					}
				}*//*
				repository.putAggregatedVulnerability(agVuln);
			} catch (ClassCastException ex) {
				System.err.println(ex.getLocalizedMessage());
				continue;
			}

		}
		return repository;
	}*/

}
