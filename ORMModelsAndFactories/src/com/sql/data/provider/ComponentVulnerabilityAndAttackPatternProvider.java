package com.sql.data.provider;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.hibernate.NonUniqueObjectException;
import org.hibernate.Session;
import org.hibernate.query.NativeQuery;
import org.hibernate.Transaction;
import org.hibernate.exception.ConstraintViolationException;

import com.sql.data.objects.aggregations.ComponentVulnerability;
import com.sql.data.objects.aggregations.VulnerableComponent;
import com.sql.data.objects.persistence.attackpatterns.CAPECCore;
import com.sql.data.objects.persistence.report.AggregatedVulnerabilityFact;
import com.sql.data.objects.persistence.report.AttackPattern;
import com.sql.data.objects.persistence.report.AttackPatternPK;
import com.sql.data.objects.persistence.report.vulnerabilitymanagement.ManagedVulnerability;
import com.sql.data.objects.persistence.vulnerabilities.CVECore;
import com.sql.data.objects.persistence.vulnerabilities.CVECorePK;
import com.sql.data.objects.persistence.vulnerabilities.Description;
import com.sql.hibernate.HibernateInstance;
import com.sql.hibernate.HibernateReportInstance;

public class ComponentVulnerabilityAndAttackPatternProvider {

	public void createVulnerableComponentsForReportID(int reportID) {
		Session reportSession = HibernateReportInstance.getSessionFactory().openSession();
		Session coreDataSession = HibernateInstance.getSessionFactory().openSession();
		String sql = "SELECT * FROM aggregatedvulnerabilityfact WHERE reportID = :reportID GROUP BY cveYear, cveID ORDER BY componentID, cveYear, cveID";
		NativeQuery<AggregatedVulnerabilityFact> agVulnFactQuery = reportSession.createNativeQuery(sql,
				AggregatedVulnerabilityFact.class);
		agVulnFactQuery.setParameter("reportID", reportID);
		List<AggregatedVulnerabilityFact> agVulnFacts = agVulnFactQuery.list();
		List<com.sql.data.objects.persistence.report.VulnerableComponent> vulnerableComponents = new ArrayList<com.sql.data.objects.persistence.report.VulnerableComponent>();
		for (AggregatedVulnerabilityFact vulnFact : agVulnFacts) {
			com.sql.data.objects.persistence.report.VulnerableComponent component = null;
			for (com.sql.data.objects.persistence.report.VulnerableComponent vulnComp : vulnerableComponents) {
				if (vulnComp.getComponentID() == Math.toIntExact(vulnFact.getComponentID())) {
					component = vulnComp;
					break;
				}
			}
			if (component == null) {
				component = new com.sql.data.objects.persistence.report.VulnerableComponent();
				component.setSwStackID(Math.toIntExact(vulnFact.getStackID()));
				component.setPart(vulnFact.getPart());
				component.setVendor(vulnFact.getVendor());
				component.setProduct(vulnFact.getProduct());
				component.setVersion(vulnFact.getVersion());
				component.setComp_update(vulnFact.getComp_update());
				component.setEdition(vulnFact.getEdition());
				component.setSw_edition(vulnFact.getSw_edition());
				component.setComp_language(vulnFact.getComp_language());
				component.setTarget_sw(vulnFact.getTarget_sw());
				component.setTarget_hw(vulnFact.getTarget_hw());
				component.setOther(vulnFact.getOther());
				component.setComponentID(Math.toIntExact(vulnFact.getComponentID()));
				component.setReportID(reportID);
				CPEProvider cpeProvider = new CPEProvider();
				if (vulnFact.getCpeID() == 0) {
					component.setURI("");
				} else {
					component.setURI(cpeProvider.find(vulnFact.getCpeID()).getURI());
				}
				vulnerableComponents.add(component);
				Transaction tx = reportSession.beginTransaction();
				reportSession.save(component);
				tx.commit();
			}
			sql = "SELECT * FROM cve WHERE cveID = :cveID AND cveYear = :cveYear";
			NativeQuery<CVECore> cveQuery = coreDataSession.createNativeQuery(sql, CVECore.class);
			cveQuery.setParameter("cveID", vulnFact.getCveID());
			cveQuery.setParameter("cveYear", vulnFact.getCveYear());
			List<CVECore> cves = cveQuery.list();
			for (CVECore cve : cves) {
				if (cve.getAttackVector() == null) {
					cve.setAttackVector("TBD");
				}
				com.sql.data.objects.persistence.report.ComponentVulnerability vuln = new com.sql.data.objects.persistence.report.ComponentVulnerability();
				vuln.constructFromVulnerability(cve);
				/*
				 * Retrieve all Descriptions
				 */
				sql = "SELECT * FROM description WHERE cveID = :cveID AND cveYear = :cveYear";
				NativeQuery<Description> descQuery = coreDataSession.createNativeQuery(sql, Description.class);
				descQuery.setParameter("cveID", cve.getCveID());
				descQuery.setParameter("cveYear", cve.getCveYear());
				List<Description> descriptions = descQuery.list();
				for (Description description : descriptions) {
					vuln.constructFromDescription(description);
				}
				vuln.setUri(cve.getIdentifierString());
				vuln.setVulnCompID(component.getVulnCompID());
				try {
					Transaction tx = reportSession.beginTransaction();
					reportSession.save(vuln);
					/*
					 * Retrieve all Attack Patterns
					 */
					sql = "SELECT a.* FROM attackpattern a, capeccwerelationship ccrel, problemtype prob WHERE (a.id = ccrel.CAPECId) AND (ccrel.CWEId = prob.weaknessID) AND (prob.cveYear = :cveYear AND prob.cveID= :cveID );";
					NativeQuery<CAPECCore> attPattQuery = coreDataSession.createNativeQuery(sql, CAPECCore.class);
					attPattQuery.setParameter("cveYear", cve.getCveYear());
					attPattQuery.setParameter("cveID", cve.getCveID());
					List<CAPECCore> attackPatterns = attPattQuery.list();
					for (CAPECCore attackPattern : attackPatterns) {
						try {
							AttackPattern persistentPattern = reportSession.find(AttackPattern.class,
									new AttackPatternPK(attackPattern.getId(), component.getVulnCompID(),
											cve.getAttackVector()));
							if (persistentPattern == null) {
								persistentPattern = new AttackPattern();
								persistentPattern.constructFromCAPEC(attackPattern);
								persistentPattern.setVulnCompID(component.getVulnCompID());
								persistentPattern.setAttackVector(cve.getAttackVector()==null?"TBD":cve.getAttackVector());
								reportSession.save(persistentPattern);
							}
						} catch (NonUniqueObjectException ex) {

						}
					}
					tx.commit();
				} catch (ConstraintViolationException ex) {
					ex.printStackTrace();
				}
			}
		}
	}

	public void setComponentVulnerabilityForReportIDAndIdentifierStringAsTreated(int reportID, Long componentID, String identifierString) {
		ManagedVulnerabilityProvider managedVulnProvider = new ManagedVulnerabilityProvider();
		ManagedVulnerability vulnerability = managedVulnProvider.find(identifierString);
		if (vulnerability == null) {
			CVECore cve = new CVECore();
			vulnerability = new ManagedVulnerability();
			cve.parseIdentifierString(identifierString);
			vulnerability.setIdentifier(identifierString);
			vulnerability.setCveID(cve.getCveID());
			vulnerability.setCveYear(cve.getCveYear());
			vulnerability.setTreated(true);			
			managedVulnProvider.persist(vulnerability);
		}
	}
	
	public void deleteComponentVulnerabilityForReportIDAndIdentifierString(int reportID, Long componentID,
			String identifierString) {
		Session reportSession = HibernateReportInstance.getSessionFactory().openSession();
		String sql = "SELECT * FROM vulnerablecomponent WHERE reportID=:reportID AND componentID=:componentID";
		NativeQuery<com.sql.data.objects.persistence.report.VulnerableComponent> componentQuery = reportSession
				.createNativeQuery(sql, com.sql.data.objects.persistence.report.VulnerableComponent.class);
		componentQuery.setParameter("reportID", reportID);
		componentQuery.setParameter("componentID", componentID);
		com.sql.data.objects.persistence.report.VulnerableComponent comp = componentQuery.getSingleResult();
		if (comp != null) {
			sql = "SELECT * FROM componentvulnerability WHERE vulnCompID=:vulnCompID AND identifierString=:identifierString";
			NativeQuery<com.sql.data.objects.persistence.report.ComponentVulnerability> compVulnQuery = reportSession.createNativeQuery(sql,
					com.sql.data.objects.persistence.report.ComponentVulnerability.class);
			compVulnQuery.setParameter("vulnCompID", comp.getVulnCompID());
			compVulnQuery.setParameter("identifierString", identifierString);
			com.sql.data.objects.persistence.report.ComponentVulnerability vuln = compVulnQuery.getSingleResult();
			if (vuln != null) {
				Transaction tx = reportSession.beginTransaction();
				reportSession.delete(vuln);
				tx.commit();
			}
		}
		reportSession.close();
	}

	public List<VulnerableComponent> getVulnerableComponentsForReportID(int reportID) {
		Session reportSession = HibernateReportInstance.getSessionFactory().openSession();
		Session coreDataSession = HibernateInstance.getSessionFactory().openSession();

		String sql = "SELECT * FROM aggregatedvulnerabilityfact WHERE reportID=:reportID ORDER BY componentID";
		NativeQuery<AggregatedVulnerabilityFact> agVulnFactQuery = reportSession.createNativeQuery(sql,
				AggregatedVulnerabilityFact.class);
		agVulnFactQuery.setParameter("reportID", reportID);
		List<AggregatedVulnerabilityFact> agVulnFacts = agVulnFactQuery.list();
		List<VulnerableComponent> vulnerableComponents = new ArrayList<VulnerableComponent>();
		Map<Long, List<CVECorePK>> cveKeyMap = new HashMap<Long, List<CVECorePK>>();
		Map<Long, List<Integer>> capecKeyMap = new HashMap<Long, List<Integer>>();
		// List<CVECorePK> cveKeys = new ArrayList<CVECorePK>(); // List for redundancy
		// checking. If cve is already in
		factLoop: for (AggregatedVulnerabilityFact vulnFact : agVulnFacts) {
			if (cveKeyMap.get(vulnFact.getComponentID()) == null) {
				cveKeyMap.put(vulnFact.getComponentID(), new ArrayList<CVECorePK>());
			} else {
				List<CVECorePK> cvePKList = cveKeyMap.get(vulnFact.getComponentID());
				for (CVECorePK cvePK : cvePKList) {
					if (cvePK.getCveID() == vulnFact.getCveID() && cvePK.getCveYear() == vulnFact.getCveYear()) {
						continue factLoop;
					}
				}
			}
			cveKeyMap.get(vulnFact.getComponentID()).add(new CVECorePK(vulnFact.getCveYear(), vulnFact.getCveID()));
			VulnerableComponent component = null;
			for (VulnerableComponent vulnComp : vulnerableComponents) {
				if (vulnComp.getComponentID().equals(vulnFact.getComponentID())) {
					component = vulnComp;
					break;
				}
			}
			if (component == null) {
				component = new VulnerableComponent();
				component.setSwStackID(vulnFact.getStackID());
				component.setPart(vulnFact.getPart());
				component.setVendor(vulnFact.getVendor());
				component.setProduct(vulnFact.getProduct());
				component.setVersion(vulnFact.getVersion());
				component.setComp_update(vulnFact.getComp_update());
				component.setEdition(vulnFact.getEdition());
				component.setSw_edition(vulnFact.getSw_edition());
				component.setComp_language(vulnFact.getComp_language());
				component.setTarget_sw(vulnFact.getTarget_sw());
				component.setTarget_hw(vulnFact.getTarget_hw());
				component.setOther(vulnFact.getOther());
				component.setComponentID(vulnFact.getComponentID());
				vulnerableComponents.add(component);
			}
			/*
			 * Retrieve all Vulnerabilities
			 */
			sql = "SELECT * FROM cve WHERE cveID = :cveID AND cveYear = :cveYear";
			NativeQuery<CVECore> cveQuery = coreDataSession.createNativeQuery(sql, CVECore.class);
			cveQuery.setParameter("cveID", vulnFact.getCveID());
			cveQuery.setParameter("cveYear", vulnFact.getCveYear());
			List<CVECore> cves = cveQuery.list();

			// list, it is not added to the component.
			for (CVECore cve : cves) {
				ComponentVulnerability vuln = new ComponentVulnerability();
				vuln.constructFromVulnerability(cve);
				/*
				 * Retrieve all Descriptions
				 */
				sql = "SELECT * FROM description WHERE cveID = :cveID AND cveYear = :cveYear";
				NativeQuery<Description> descQuery = coreDataSession.createNativeQuery(sql, Description.class);
				descQuery.setParameter("cveID", cve.getCveID());
				descQuery.setParameter("cveYear", cve.getCveYear());
				List<Description> descriptions = descQuery.list();
				for (Description description : descriptions) {
					vuln.constructFromDescription(description);
				}
				component.getComponentVulnerabilities().add(vuln);
				/*
				 * Retrieve all Attack Patterns
				 */
				sql = "SELECT a.* FROM attackpattern a, capeccwerelationship ccrel, problemtype prob WHERE (a.id = ccrel.CAPECId) AND (ccrel.CWEId = prob.weaknessID) AND (prob.cveYear = :cveYear AND prob.cveID= :cveID );";
				NativeQuery<CAPECCore> attPattQuery = coreDataSession.createNativeQuery(sql, CAPECCore.class);
				attPattQuery.setParameter("cveYear", cve.getCveYear());
				attPattQuery.setParameter("cveID", cve.getCveID());
				List<CAPECCore> attackPatterns = attPattQuery.list();
				AttackPatternLoop: for (CAPECCore attackPattern : attackPatterns) {
					if (capecKeyMap.get(vulnFact.getComponentID()) == null) {
						capecKeyMap.put(vulnFact.getComponentID(), new ArrayList<Integer>());
					} else {
						List<Integer> capecKeyList = capecKeyMap.get(vulnFact.getComponentID());
						for (Integer capecKey : capecKeyList) {
							if (capecKey.equals(attackPattern.getId())) {
								continue AttackPatternLoop;
							}
						}
					}
					capecKeyMap.get(vulnFact.getComponentID()).add(attackPattern.getId());
					component.getAttackPatterns().add(attackPattern);
				}
			}
		}
		for (VulnerableComponent component : vulnerableComponents) {
			component.sanitizeHTMLStrings();
		}
		return vulnerableComponents;
	}

	private boolean isFoundInKeyList(List<CVECorePK> cveKeys, CVECore cve) {
		if (cveKeys.size() == 0) {
			cveKeys.add(new CVECorePK(cve.getCveYear(), cve.getCveID()));
		} else {
			for (CVECorePK cveKey : cveKeys) {
				if (cveKey.getCveYear() == cve.getCveYear() && cveKey.getCveID() == cve.getCveID()) {
					return true;
				}
			}
		}
		return false;
	}

}
